# -*- coding: utf-8 -*-
"""Classificador BPMN_SBMN_utilizando LLM_1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MIqtnVBtb_2h19mQSKp84kVuloyzg4nh
"""

# =========================
# 1. Instala√ß√£o e imports
# =========================
!pip install openai lxml

import json
import xml.etree.ElementTree as ET
from openai import OpenAI

client = OpenAI(api_key="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")  # configure com sua chave de API

# =========================
# 2. Fun√ß√£o SBMN -> Texto
# =========================
def sbmn_to_text(sbmn_json):
    atividades = ", ".join(sbmn_json["atividades"])
    restricoes = []
    for r in sbmn_json["restricoes"]:
        if r["tipo"] == "DEP":
            restricoes.append(f"{r['para']} depende de {r['de']}")
        elif r["tipo"] == "XOR":
            restricoes.append(f"{' e '.join(r['entre'])} s√£o mutuamente exclusivos")
        elif r["tipo"] == "UNI":
            restricoes.append(f"{' e '.join(r['entre'])} podem ocorrer juntos ou separados (uni√£o)")
        elif r["tipo"] == "JUMP":
            restricoes.append(f"A execu√ß√£o de {r['de']} pode saltar o fluxo para {r['para']} (jump)")
    return f"Atividades: {atividades}. Restri√ß√µes: {'; '.join(restricoes)}."


# =========================
# 3. Fun√ß√£o BPMN -> Texto
# =========================
def bpmn_to_text(bpmn_xml_str):
    root = ET.fromstring(bpmn_xml_str)
    tasks = [el.attrib.get("name", el.attrib["id"]) for el in root.findall(".//{*}task")]
    flows = [(f.attrib["sourceRef"], f.attrib["targetRef"]) for f in root.findall(".//{*}sequenceFlow")]
    return f"Tarefas: {', '.join(tasks)}. Fluxos: {', '.join([f'{a}->{b}' for a,b in flows])}."


# =========================
# 4. Exemplo fict√≠cio SBMN
# =========================
sbmn_example = {
    "atividades": ["Receber Pedido", "Verificar Estoque", "Aprovar Pedido", "Enviar Produto", "Notificar Cliente"],
    "restricoes": [
        {"tipo": "DEP", "de": "Verificar Estoque", "para": "Aprovar Pedido"},
        {"tipo": "XOR", "entre": ["Aprovar Pedido", "Enviar Produto"]},
        {"tipo": "UNI", "entre": ["Notificar Cliente", "Aprovar Pedido"]},
        {"tipo": "JUMP", "de": "Notificar Cliente", "para": "Verificar Estoque"}
    ]
}

sbmn_text = sbmn_to_text(sbmn_example)
print("SBMN (texto):", sbmn_text)


# =========================
# 5. Dois BPMNs fict√≠cios
# =========================

# Modelo 1: sem loop (n√£o respeita o JUMP)
bpmn1 = """
<process id="Process_1">
  <task id="t1" name="Receber Pedido"/>
  <task id="t2" name="Verificar Estoque"/>
  <task id="t3" name="Aprovar Pedido"/>
  <task id="t4" name="Enviar Produto"/>
  <task id="t5" name="Notificar Cliente"/>
  <sequenceFlow sourceRef="t1" targetRef="t2"/>
  <sequenceFlow sourceRef="t2" targetRef="t3"/>
  <sequenceFlow sourceRef="t3" targetRef="t4"/>
  <sequenceFlow sourceRef="t3" targetRef="t5"/>
</process>
"""

# Modelo 2: com loop (respeita o JUMP de Notificar Cliente -> Verificar Estoque)
bpmn2 = """
<process id="Process_2">
  <task id="t1" name="Receber Pedido"/>
  <task id="t2" name="Verificar Estoque"/>
  <task id="t3" name="Aprovar Pedido"/>
  <task id="t4" name="Enviar Produto"/>
  <task id="t5" name="Notificar Cliente"/>
  <sequenceFlow sourceRef="t1" targetRef="t2"/>
  <sequenceFlow sourceRef="t2" targetRef="t3"/>
  <sequenceFlow sourceRef="t3" targetRef="t4"/>
  <sequenceFlow sourceRef="t3" targetRef="t5"/>
  <sequenceFlow sourceRef="t5" targetRef="t2"/> <!-- Loop implementando o Jump -->
</process>
"""

bpmn1_text = bpmn_to_text(bpmn1)
bpmn2_text = bpmn_to_text(bpmn2)

print("BPMN1 (texto):", bpmn1_text)
print("BPMN2 (texto):", bpmn2_text)


# =========================
# 6. Prompt para a LLM
# =========================
prompt = f"""
Voc√™ √© um especialista em modelagem de processos.

Modelo de restri√ß√µes (SBMN):
{sbmn_text}

Modelo 1 (BPMN):
{bpmn1_text}

Modelo 2 (BPMN):
{bpmn2_text}

Importante:
- DEP = depend√™ncia (uma tarefa s√≥ ocorre se outra ocorreu antes).
- XOR = exclus√£o (duas tarefas n√£o podem ocorrer no mesmo fluxo).
- UNI = uni√£o (todas combina√ß√µes devem existir).
- JUMP = salto/la√ßo: uma atividade pode redirecionar o fluxo para outra, inclusive retornando a etapas anteriores.

Pergunta: Qual dos dois modelos BPMN respeita melhor as restri√ß√µes do SBMN, incluindo o jump?
Responda apenas com 'Modelo 1' ou 'Modelo 2' e depois explique em 2 frases o porqu√™.
"""

# =========================
# 7. Chamada √† LLM
# =========================
response = client.chat.completions.create(
    model="gpt-4o-mini",
    messages=[{"role": "user", "content": prompt}]
)

print("Resposta da LLM:", response.choices[0].message.content)

# =========================
# 1. Instala√ß√£o e imports
# =========================
!pip install openai lxml pandas

import os
import json
import pandas as pd
import xml.etree.ElementTree as ET
from openai import OpenAI

# Configure sua chave
# client = OpenAI(api_key=os.environ.get("OPENAI_API_KEY", "SUA_CHAVE_AQUI"))
client = OpenAI(api_key="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")  # configure com sua chave de API

# =========================
# 2. Fun√ß√£o SBMN -> Texto
# =========================
def sbmn_to_text(sbmn_json):
    atividades = ", ".join(sbmn_json["atividades"])
    restricoes = []
    for r in sbmn_json["restricoes"]:
        if r["tipo"] == "DEP":
            restricoes.append(f"{r['para']} depende de {r['de']}")
        elif r["tipo"] == "XOR":
            restricoes.append(f"{' e '.join(r['entre'])} s√£o mutuamente exclusivos")
        elif r["tipo"] == "UNI":
            restricoes.append(f"{' e '.join(r['entre'])} podem ocorrer juntos ou separados (uni√£o)")
        elif r["tipo"] == "JUMP":
            restricoes.append(f"A execu√ß√£o de {r['de']} pode saltar o fluxo para {r['para']} (jump)")
    return f"Atividades: {atividades}. Restri√ß√µes: {'; '.join(restricoes)}."


# =========================
# 3. Fun√ß√£o BPMN -> Texto
# =========================
def bpmn_to_text(bpmn_xml_str):
    root = ET.fromstring(bpmn_xml_str)
    tasks = [el.attrib.get("name", el.attrib["id"]) for el in root.findall(".//{*}task")]
    flows = [(f.attrib["sourceRef"], f.attrib["targetRef"]) for f in root.findall(".//{*}sequenceFlow")]
    return f"Tarefas: {', '.join(tasks)}. Fluxos: {', '.join([f'{a}->{b}' for a,b in flows])}."


# =========================
# 4. Fun√ß√£o para avalia√ß√£o com LLM
# =========================
def avaliar_modelos(sbmn_text, bpmn1_text, bpmn2_text):
    prompt = f"""
    Voc√™ √© um especialista em modelagem de processos.

    Modelo de restri√ß√µes (SBMN):
    {sbmn_text}

    Modelo 1 (BPMN):
    {bpmn1_text}

    Modelo 2 (BPMN):
    {bpmn2_text}

    Importante:
    - DEP = depend√™ncia (uma tarefa s√≥ ocorre se outra ocorreu antes).
    - XOR = exclus√£o (duas tarefas n√£o podem ocorrer no mesmo fluxo).
    - UNI = uni√£o (todas combina√ß√µes devem existir).
    - JUMP = salto/la√ßo: uma atividade pode redirecionar o fluxo para outra, inclusive retornando a etapas anteriores.

    Pergunta: Qual dos dois modelos BPMN respeita melhor as restri√ß√µes do SBMN, incluindo os jumps?
    Responda apenas com 'Modelo 1' ou 'Modelo 2' e depois explique em 2 frases o porqu√™.
    """

    response = client.chat.completions.create(
        model="gpt-4o-mini",
        messages=[{"role": "user", "content": prompt}]
    )

    resposta = response.choices[0].message.content

    if "Modelo 1" in resposta:
        vencedor = "Modelo 1"
    elif "Modelo 2" in resposta:
        vencedor = "Modelo 2"
    else:
        vencedor = "Indefinido"

    return vencedor, resposta


# =========================
# 5. Exemplo de execu√ß√£o em lote
# =========================

# Lista de cen√°rios (cada item = 1 SBMN + 2 BPMNs)
cenarios = [
    {
        "sbmn": {
            "atividades": ["Receber Pedido", "Verificar Estoque", "Aprovar Pedido", "Enviar Produto", "Notificar Cliente"],
            "restricoes": [
                {"tipo": "DEP", "de": "Verificar Estoque", "para": "Aprovar Pedido"},
                {"tipo": "XOR", "entre": ["Aprovar Pedido", "Enviar Produto"]},
                {"tipo": "UNI", "entre": ["Notificar Cliente", "Aprovar Pedido"]},
                {"tipo": "JUMP", "de": "Notificar Cliente", "para": "Verificar Estoque"}
            ]
        },
        "bpmn1": """
        <process id="Process_1">
          <task id="t1" name="Receber Pedido"/>
          <task id="t2" name="Verificar Estoque"/>
          <task id="t3" name="Aprovar Pedido"/>
          <task id="t4" name="Enviar Produto"/>
          <task id="t5" name="Notificar Cliente"/>
          <sequenceFlow sourceRef="t1" targetRef="t2"/>
          <sequenceFlow sourceRef="t2" targetRef="t3"/>
          <sequenceFlow sourceRef="t3" targetRef="t4"/>
          <sequenceFlow sourceRef="t3" targetRef="t5"/>
        </process>
        """,
        "bpmn2": """
        <process id="Process_2">
          <task id="t1" name="Receber Pedido"/>
          <task id="t2" name="Verificar Estoque"/>
          <task id="t3" name="Aprovar Pedido"/>
          <task id="t4" name="Enviar Produto"/>
          <task id="t5" name="Notificar Cliente"/>
          <sequenceFlow sourceRef="t1" targetRef="t2"/>
          <sequenceFlow sourceRef="t2" targetRef="t3"/>
          <sequenceFlow sourceRef="t3" targetRef="t4"/>
          <sequenceFlow sourceRef="t3" targetRef="t5"/>
          <sequenceFlow sourceRef="t5" targetRef="t2"/> <!-- Loop implementando o Jump -->
        </process>
        """
    }
]

# =========================
# 6. Rodar os cen√°rios e salvar resultados
# =========================
resultados = []

for c in cenarios:
    sbmn_text = sbmn_to_text(c["sbmn"])
    bpmn1_text = bpmn_to_text(c["bpmn1"])
    bpmn2_text = bpmn_to_text(c["bpmn2"])

    vencedor, explicacao = avaliar_modelos(sbmn_text, bpmn1_text, bpmn2_text)

    resultados.append({
        "SBMN": sbmn_text,
        "BPMN1": bpmn1_text,
        "BPMN2": bpmn2_text,
        "Vencedor": vencedor,
        "Explicacao": explicacao
    })

# Salvar em CSV
df = pd.DataFrame(resultados)
df.to_csv("resultados_comparacao.csv", index=False)
df

import zipfile
def descompactar_arquivos_zip(zip_path, extract_path):
    with zipfile.ZipFile(zip_path, 'r') as zip_ref:
        zip_ref.extractall(extract_path)
    print(f"Arquivos extra√≠dos para: {extract_path}")

descompactar_arquivos_zip("/content/ITIL.zip", "/content/ITIL")

# =========================
# 1. Instala√ß√£o e imports
# =========================
!pip install openai lxml pandas

import os
import json
import pandas as pd
import xml.etree.ElementTree as ET
from openai import OpenAI

# Configure sua chave (se j√° estiver no ambiente, n√£o precisa trocar aqui)
# client = OpenAI(api_key=os.environ.get("OPENAI_API_KEY", "SUA_CHAVE_AQUI"))
client = OpenAI(api_key="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")  # configure com sua chave de API

# =========================
# 2. Fun√ß√£o SBMN -> Texto
# =========================
def sbmn_to_text(sbmn_json):
    # Atividades
    atividades = [a["nome"] for a in sbmn_json["Atividades"]]
    atividades_str = ", ".join(atividades)

    # Restri√ß√µes
    restricoes = []
    id_para_nome = {a["id"]: a["nome"] for a in sbmn_json["Atividades"]}

    for r in sbmn_json["Situacoes"]:
        esquerda = ", ".join([id_para_nome[e["id"]] for e in r["esquerda"]])
        direita = ", ".join([id_para_nome[d["id"]] for d in r["direita"]])
        op = r["operador"]

        if op == "DEP":
            restricoes.append(f"{direita} depende de {esquerda}")
        elif op == "DEPC":
            restricoes.append(f"{direita} depende condicionalmente de {esquerda}")
        elif op == "XOR":
            restricoes.append(f"{esquerda} e {direita} s√£o mutuamente exclusivos")
        elif op == "UNI":
            restricoes.append(f"{esquerda} e {direita} podem ocorrer juntos ou separados (uni√£o)")
        elif op == "JMP":
            restricoes.append(f"{esquerda} pode saltar o fluxo para {direita} (jump)")
        else:
            restricoes.append(f"{esquerda} {op} {direita}")  # fallback gen√©rico

    restricoes_str = "; ".join(restricoes)

    return f"Atividades: {atividades_str}. Restri√ß√µes: {restricoes_str}."



# =========================
# 3. Fun√ß√£o BPMN -> Texto
# =========================
def bpmn_to_text(bpmn_xml_str):
    root = ET.fromstring(bpmn_xml_str)
    tasks = [el.attrib.get("name", el.attrib["id"]) for el in root.findall(".//{*}task")]
    flows = [(f.attrib["sourceRef"], f.attrib["targetRef"]) for f in root.findall(".//{*}sequenceFlow")]
    return f"Tarefas: {', '.join(tasks)}. Fluxos: {', '.join([f'{a}->{b}' for a,b in flows])}."


# =========================
# 4. Fun√ß√£o para avalia√ß√£o com LLM
# =========================
def avaliar_modelos(sbmn_text, bpmn1_text, bpmn2_text):
    prompt = f"""
    Voc√™ √© um especialista em modelagem de processos.

    Modelo de restri√ß√µes (SBMN):
    {sbmn_text}

    Modelo 1 (BPMN):
    {bpmn1_text}

    Modelo 2 (BPMN):
    {bpmn2_text}

    Importante:
    - DEP = depend√™ncia (uma tarefa s√≥ ocorre se outra ocorreu antes).
    - XOR = exclus√£o (duas tarefas n√£o podem ocorrer no mesmo fluxo).
    - UNI = uni√£o (todas combina√ß√µes devem existir).
    - JUMP = salto/la√ßo: uma atividade pode redirecionar o fluxo para outra, inclusive retornando a etapas anteriores.

    Pergunta: Qual dos dois modelos BPMN respeita melhor as restri√ß√µes do SBMN, incluindo os jumps?
    Responda apenas com 'Modelo 1' ou 'Modelo 2' e depois explique em 2 frases o porqu√™.
    """

    response = client.chat.completions.create(
        model="gpt-4o-mini",
        messages=[{"role": "user", "content": prompt}]
    )

    resposta = response.choices[0].message.content

    if "Modelo 1" in resposta:
        vencedor = "Modelo 1"
    elif "Modelo 2" in resposta:
        vencedor = "Modelo 2"
    else:
        vencedor = "Indefinido"

    return vencedor, resposta


# =========================
# 5. Caminhos das pastas
# =========================
PASTA_SBMN = "/content/SBMN"
PASTA_BPMN = "/content/BPMN"

# Crie as pastas no Colab se ainda n√£o existirem
os.makedirs(PASTA_SBMN, exist_ok=True)
os.makedirs(PASTA_BPMN, exist_ok=True)

print("üìÇ Pastas preparadas!")
print("SBMN em:", PASTA_SBMN)
print("BPMN em:", PASTA_BPMN)


# =========================
# 6. Carregar arquivos e rodar pares
# =========================
sbmn_files = [f for f in os.listdir(PASTA_SBMN) if f.lower().endswith(".json")]
# bpmn_files = [f for f in os.listdir(PASTA_BPMN) if f.endswith(".xml")]
# Converte tudo para min√∫sculo e aceita .bpmn ou .xml
bpmn_files = [f for f in os.listdir(PASTA_BPMN) if f.lower().endswith((".bpmn", ".xml"))]

resultados = []

# Para cada SBMN, compara todos os pares poss√≠veis de BPMNs
for sbmn_file in sbmn_files:
    with open(os.path.join(PASTA_SBMN, sbmn_file), "r", encoding="utf-8") as f:
        sbmn_data = json.load(f)
        sbmn_text = sbmn_to_text(sbmn_data)

    for i in range(len(bpmn_files)):
        for j in range(i + 1, len(bpmn_files)):
            bpmn1 = open(os.path.join(PASTA_BPMN, bpmn_files[i]), "r", encoding="utf-8").read()
            bpmn2 = open(os.path.join(PASTA_BPMN, bpmn_files[j]), "r", encoding="utf-8").read()

            bpmn1_text = bpmn_to_text(bpmn1)
            bpmn2_text = bpmn_to_text(bpmn2)

            vencedor, explicacao = avaliar_modelos(sbmn_text, bpmn1_text, bpmn2_text)

            resultados.append({
                "SBMN_Arquivo": sbmn_file,
                "BPMN1_Arquivo": bpmn_files[i],
                "BPMN2_Arquivo": bpmn_files[j],
                "SBMN": sbmn_text,
                "BPMN1": bpmn1_text,
                "BPMN2": bpmn2_text,
                "Vencedor": vencedor,
                "Explicacao": explicacao
            })



# =========================
# 7. Salvar em CSV
# =========================
df = pd.DataFrame(resultados)
df.to_csv("resultados_comparacao.csv", index=False)
df

df_resumo = df[["SBMN_Arquivo", "BPMN1_Arquivo", "BPMN2_Arquivo", "Vencedor", "Explicacao"]]
df_resumo.to_csv("resultados_resumo.csv", index=False)
df_resumo

from IPython.display import display

print("üìä Resultados da Compara√ß√£o SBMN x BPMN")
display(df_resumo.style.set_properties(**{
    'background-color': '#f9f9f9',
    'border': '1px solid #ddd',
    'color': 'black'
}).set_table_styles([
    {'selector': 'th', 'props': [('background-color', '#4CAF50'),
                                 ('color', 'white'),
                                 ('text-align', 'center')]}
]))

df_resumo.to_excel("resultados_resumo.xlsx", index=False)

# =========================
# 1. Instala√ß√£o e imports
# =========================
!pip install openai lxml pandas

import os
import json
import pandas as pd
import xml.etree.ElementTree as ET
from openai import OpenAI
import zipfile

# Configure sua chave (se j√° estiver no ambiente, n√£o precisa trocar aqui)
# client = OpenAI(api_key=os.environ.get("OPENAI_API_KEY", "SUA_CHAVE_AQUI"))
client = OpenAI(api_key="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")  # configure com sua chave de API

# =========================
# 2. Fun√ß√£o SBMN -> Texto
# =========================
def sbmn_to_text(sbmn_json):
    atividades = [a["nome"] for a in sbmn_json["Atividades"]]
    atividades_str = ", ".join(atividades)

    restricoes = []
    id_para_nome = {a["id"]: a["nome"] for a in sbmn_json["Atividades"]}

    for r in sbmn_json["Situacoes"]:
        esquerda = ", ".join([id_para_nome[e["id"]] for e in r["esquerda"]])
        direita = ", ".join([id_para_nome[d["id"]] for d in r["direita"]])
        op = r["operador"]

        if op == "DEP":
            restricoes.append(f"{direita} depende de {esquerda}")
        elif op == "DEPC":
            restricoes.append(f"{direita} depende condicionalmente de {esquerda}")
        elif op == "XOR":
            restricoes.append(f"{esquerda} e {direita} s√£o mutuamente exclusivos")
        elif op == "UNI":
            restricoes.append(f"{esquerda} e {direita} podem ocorrer juntos ou separados (uni√£o)")
        elif op == "JMP":
            restricoes.append(f"{esquerda} pode saltar o fluxo para {direita} (jump)")
        else:
            restricoes.append(f"{esquerda} {op} {direita}")  # fallback gen√©rico

    restricoes_str = "; ".join(restricoes)
    return f"Atividades: {atividades_str}. Restri√ß√µes: {restricoes_str}."


# =========================
# 3. Fun√ß√£o BPMN -> Texto
# =========================
def bpmn_to_text(bpmn_xml_str):
    root = ET.fromstring(bpmn_xml_str)
    tasks = [el.attrib.get("name", el.attrib["id"]) for el in root.findall(".//{*}task")]
    flows = [(f.attrib["sourceRef"], f.attrib["targetRef"]) for f in root.findall(".//{*}sequenceFlow")]
    return f"Tarefas: {', '.join(tasks)}. Fluxos: {', '.join([f'{a}->{b}' for a,b in flows])}."


# =========================
# 4. Fun√ß√£o para avalia√ß√£o com LLM
# =========================
def avaliar_modelos(sbmn_text, bpmn1_text, bpmn2_text):
    prompt = f"""
    Voc√™ √© um especialista em modelagem de processos.

    Modelo de restri√ß√µes (SBMN):
    {sbmn_text}

    Modelo 1 (BPMN):
    {bpmn1_text}

    Modelo 2 (BPMN):
    {bpmn2_text}

    Importante:
    - DEP = depend√™ncia
    - XOR = exclus√£o
    - UNI = uni√£o
    - JUMP = salto/la√ßo

    Pergunta: Qual dos dois modelos BPMN respeita melhor as restri√ß√µes do SBMN, incluindo os jumps?
    Responda apenas com 'Modelo 1' ou 'Modelo 2' e depois explique em 2 frases o porqu√™.
    """

    response = client.chat.completions.create(
        model="gpt-4o-mini",
        messages=[{"role": "user", "content": prompt}]
    )

    resposta = response.choices[0].message.content

    if "Modelo 1" in resposta:
        vencedor = "Modelo 1"
    elif "Modelo 2" in resposta:
        vencedor = "Modelo 2"
    else:
        vencedor = "Indefinido"

    return vencedor, resposta


# =========================
# 5. M√©dia harm√¥nica ponderada
# =========================
def harmonic_mean_weighted(metrics: dict, weights: dict, eps=1e-6):
    num, den = 0.0, 0.0
    for k, w in weights.items():
        if k not in metrics or metrics[k] is None:
            continue
        m = max(eps, float(metrics[k]))
        num += w
        den += w / m
    return num / den if den > 0 else 0.0

W = {"precision": 0.4, "fitness": 0.3, "generalization": 0.2, "simplicity": 0.1}

def decidir_com_hmean_e_llm(metrics1, metrics2, voto_llm, delta=0.03, weights=W):
    h1 = harmonic_mean_weighted(metrics1, weights)
    h2 = harmonic_mean_weighted(metrics2, weights)
    if abs(h1 - h2) >= delta:
        vencedor = "Modelo 1" if h1 > h2 else "Modelo 2"
        criterio = f"H-mean ({h1:.3f} vs {h2:.3f}, Œî={abs(h1-h2):.3f} ‚â• {delta})"
    else:
        vencedor = voto_llm
        criterio = f"LLM (Œî={abs(h1-h2):.3f} < {delta})"
    return vencedor, h1, h2, criterio


# =========================
# 6. Pastas
# =========================
PASTA_SBMN = "/content/sbmn"
PASTA_BPMN = "/content/bpmn"
PASTA_REF = "/content/bpmn_ref"

os.makedirs(PASTA_SBMN, exist_ok=True)
os.makedirs(PASTA_BPMN, exist_ok=True)
os.makedirs(PASTA_REF, exist_ok=True)


# =========================
# 7. Loop de compara√ß√£o
# =========================
sbmn_files = [f for f in os.listdir(PASTA_SBMN) if f.lower().endswith(".json")]
bpmn_files = [f for f in os.listdir(PASTA_BPMN) if f.lower().endswith((".bpmn", ".xml"))]

resultados = []

for sbmn_file in sbmn_files:
    with open(os.path.join(PASTA_SBMN, sbmn_file), "r", encoding="utf-8") as f:
        sbmn_data = json.load(f)
        sbmn_text = sbmn_to_text(sbmn_data)

    for i in range(len(bpmn_files)):
        for j in range(i + 1, len(bpmn_files)):
            bpmn1 = open(os.path.join(PASTA_BPMN, bpmn_files[i]), "r", encoding="utf-8").read()
            bpmn2 = open(os.path.join(PASTA_BPMN, bpmn_files[j]), "r", encoding="utf-8").read()

            bpmn1_text = bpmn_to_text(bpmn1)
            bpmn2_text = bpmn_to_text(bpmn2)

            # Aqui ainda estamos sem m√©tricas reais, ent√£o vamos simular [0.5,1.0]
            metrics1 = {"fitness": 0.95, "precision": 0.88, "generalization": 0.80, "simplicity": 0.62}
            metrics2 = {"fitness": 0.93, "precision": 0.91, "generalization": 0.79, "simplicity": 0.55}

            voto_llm, explicacao = avaliar_modelos(sbmn_text, bpmn1_text, bpmn2_text)
            vencedor, h1, h2, criterio = decidir_com_hmean_e_llm(metrics1, metrics2, voto_llm)

            resultados.append({
                "SBMN_Arquivo": sbmn_file,
                "BPMN1_Arquivo": bpmn_files[i],
                "BPMN2_Arquivo": bpmn_files[j],
                "H1": h1, "H2": h2,
                "LLM_Voto": voto_llm,
                "Vencedor": vencedor,
                "Criterio": criterio,
                "Explicacao_LLM": explicacao
            })

df = pd.DataFrame(resultados)


# =========================
# 8. Exportar resultados
# =========================
df.to_csv("resultados_comparacao_hmean.csv", index=False)
df

from IPython.display import display

print("üìä Resultados da Compara√ß√£o SBMN x BPMN")
display(df.style.set_properties(**{
    'background-color': '#f9f9f9',
    'border': '1px solid #ddd',
    'color': 'black'
}).set_table_styles([
    {'selector': 'th', 'props': [('background-color', '#4CAF50'),
                                 ('color', 'white'),
                                 ('text-align', 'center')]}
]))

# =========================
# 1. Instala√ß√£o e imports
# =========================
!pip install openai pm4py lxml pandas networkx tabulate matplotlib

import os
import json
import pandas as pd
import xml.etree.ElementTree as ET
from openai import OpenAI
import zipfile
from IPython.display import display

import pm4py
from pm4py.objects.bpmn.importer import importer as bpmn_importer
from pm4py.objects.log.importer.xes import importer as xes_importer
from pm4py.objects.conversion.bpmn.converter import apply as bpmn_to_petri
from pm4py.algo.conformance.alignments import algorithm as alignments
from pm4py.algo.evaluation import precision as precision_evaluator
from pm4py.algo.evaluation import generalization as generalization_evaluator
from pm4py.algo.evaluation import simplicity as simplicity_evaluator

import matplotlib.pyplot as plt
import numpy as np

# Configura√ß√£o da chave
client = OpenAI(api_key=os.environ.get("OPENAI_API_KEY", "SUA_CHAVE_AQUI"))


# =========================
# 2. Fun√ß√µes auxiliares
# =========================

def sbmn_to_text(sbmn_json):
    atividades = [a["nome"] for a in sbmn_json["Atividades"]]
    atividades_str = ", ".join(atividades)

    restricoes = []
    id_para_nome = {a["id"]: a["nome"] for a in sbmn_json["Atividades"]}

    for r in sbmn_json["Situacoes"]:
        esquerda = ", ".join([id_para_nome[e["id"]] for e in r["esquerda"]])
        direita = ", ".join([id_para_nome[d["id"]] for d in r["direita"]])
        op = r["operador"]

        if op == "DEP":
            restricoes.append(f"{direita} depende de {esquerda}")
        elif op == "DEPC":
            restricoes.append(f"{direita} depende condicionalmente de {esquerda}")
        elif op == "XOR":
            restricoes.append(f"{esquerda} e {direita} s√£o mutuamente exclusivos")
        elif op == "UNI":
            restricoes.append(f"{esquerda} e {direita} podem ocorrer juntos ou separados (uni√£o)")
        elif op == "JMP":
            restricoes.append(f"{esquerda} pode saltar o fluxo para {direita} (jump)")
        else:
            restricoes.append(f"{esquerda} {op} {direita}")

    restricoes_str = "; ".join(restricoes)
    return f"Atividades: {atividades_str}. Restri√ß√µes: {restricoes_str}."


def bpmn_to_text(bpmn_xml_str):
    root = ET.fromstring(bpmn_xml_str)
    tasks = [el.attrib.get("name", el.attrib["id"]) for el in root.findall(".//{*}task")]
    flows = [(f.attrib["sourceRef"], f.attrib["targetRef"]) for f in root.findall(".//{*}sequenceFlow")]
    return f"Tarefas: {', '.join(tasks)}. Fluxos: {', '.join([f'{a}->{b}' for a,b in flows])}."


def gerar_log_sintetico(bpmn_path, n_traces=200):
    bpmn_graph = bpmn_importer.apply(bpmn_path)
    net, im, fm = bpmn_to_petri(bpmn_graph)
    log = pm4py.simulation.playout.apply(
        net, im, fm,
        variant=pm4py.simulation.playout.Variants.BASIC_PLAYOUT,
        no_traces=n_traces
    )
    return log


def calcular_metricas(bpmn_path, log_path=None, n_traces=200):
    bpmn_graph = bpmn_importer.apply(bpmn_path)
    net, im, fm = bpmn_to_petri(bpmn_graph)

    if log_path and os.path.exists(log_path):
        log = xes_importer.apply(log_path)
        log_usado = "real"
    else:
        log = gerar_log_sintetico(bpmn_path, n_traces=n_traces)
        log_usado = "sint√©tico"

    aligned_traces = alignments.apply_log(log, net, im, fm)
    fitness = pm4py.algo.conformance.alignments.evaluate(aligned_traces)["averageFitness"]

    precision = precision_evaluator.apply(log, net, im, fm)
    generalization = generalization_evaluator.apply(log, net, im, fm)
    simplicity = simplicity_evaluator.apply(net)

    return {
        "fitness": fitness,
        "precision": precision,
        "generalization": generalization,
        "simplicity": simplicity,
        "log_usado": log_usado
    }


def parse_bpmn_structure(bpmn_path):
    tree = ET.parse(bpmn_path)
    root = tree.getroot()
    ns = {'bpmn': 'http://www.omg.org/spec/BPMN/20100524/MODEL'}

    tasks = set([el.attrib.get("name", el.attrib["id"]) for el in root.findall(".//bpmn:task", ns)])
    flows = set([(f.attrib["sourceRef"], f.attrib["targetRef"]) for f in root.findall(".//bpmn:sequenceFlow", ns)])
    return tasks, flows


def similaridade_estrutural(bpmn_path, ref_path):
    tasks1, flows1 = parse_bpmn_structure(bpmn_path)
    tasks2, flows2 = parse_bpmn_structure(ref_path)

    sim_tasks = len(tasks1 & tasks2) / len(tasks1 | tasks2) if tasks1 | tasks2 else 0
    sim_flows = len(flows1 & flows2) / len(flows1 | flows2) if flows1 | flows2 else 0

    return (sim_tasks + sim_flows) / 2


def harmonic_mean(metrics: dict, eps=1e-6):
    vals = [max(eps, float(metrics[k])) for k in ["fitness", "precision", "generalization", "simplicity"] if k in metrics]
    n = len(vals)
    return n / sum(1.0/v for v in vals) if n > 0 else 0.0


def harmonic_mean_weighted(metrics: dict, weights: dict, eps=1e-6):
    num, den = 0.0, 0.0
    for k, w in weights.items():
        if k not in metrics or metrics[k] is None:
            continue
        m = max(eps, float(metrics[k]))
        num += w
        den += w / m
    return num / den if den > 0 else 0.0


# Pesos padr√£o
W = {"precision": 0.4, "fitness": 0.3, "generalization": 0.2, "simplicity": 0.1}


def avaliar_modelos_completo(sbmn_text, bpmn1_text, bpmn2_text, metrics1, metrics2, sim1=None, sim2=None):
    prompt = f"""
    Voc√™ √© um especialista em modelagem de processos.

    Modelo de restri√ß√µes (SBMN):
    {sbmn_text}

    Modelo 1 (BPMN):
    {bpmn1_text}
    M√©tricas: Fitness={metrics1['fitness']:.3f}, Precision={metrics1['precision']:.3f},
    Generalization={metrics1['generalization']:.3f}, Simplicity={metrics1['simplicity']:.3f},
    Hmean={harmonic_mean(metrics1):.3f}, Hmean_weighted={harmonic_mean_weighted(metrics1, W):.3f}
    {"Similaridade estrutural com refer√™ncia: {:.3f}".format(sim1) if sim1 is not None else ""}

    Modelo 2 (BPMN):
    {bpmn2_text}
    M√©tricas: Fitness={metrics2['fitness']:.3f}, Precision={metrics2['precision']:.3f},
    Generalization={metrics2['generalization']:.3f}, Simplicity={metrics2['simplicity']:.3f},
    Hmean={harmonic_mean(metrics2):.3f}, Hmean_weighted={harmonic_mean_weighted(metrics2, W):.3f}
    {"Similaridade estrutural com refer√™ncia: {:.3f}".format(sim2) if sim2 is not None else ""}

    Pergunta: considerando restri√ß√µes (SBMN), m√©tricas, m√©dias harm√¥nicas e, se dispon√≠vel, a similaridade estrutural,
    qual dos dois modelos BPMN representa melhor o processo?
    Responda apenas com 'Modelo 1' ou 'Modelo 2' e depois explique em 2 frases.
    """

    response = client.chat.completions.create(
        model="gpt-4o-mini",
        messages=[{"role": "user", "content": prompt}]
    )
    resposta = response.choices[0].message.content

    if "Modelo 1" in resposta:
        vencedor = "Modelo 1"
    elif "Modelo 2" in resposta:
        vencedor = "Modelo 2"
    else:
        vencedor = "Indefinido"

    return vencedor, resposta


# =========================
# 3. Pastas
# =========================
PASTA_SBMN = "/content/sbmn_json"
PASTA_BPMN = "/content/bpmn_xml"
PASTA_LOGS = "/content/logs_referencia"
PASTA_REF = "/content/bpmn_ref"
PASTA_GRAFICOS = "/content/graficos_resultados"

os.makedirs(PASTA_SBMN, exist_ok=True)
os.makedirs(PASTA_BPMN, exist_ok=True)
os.makedirs(PASTA_LOGS, exist_ok=True)
os.makedirs(PASTA_REF, exist_ok=True)
os.makedirs(PASTA_GRAFICOS, exist_ok=True)


# =========================
# 4. Loop principal
# =========================
sbmn_files = [f for f in os.listdir(PASTA_SBMN) if f.lower().endswith(".json")]
bpmn_files = [f for f in os.listdir(PASTA_BPMN) if f.lower().endswith((".bpmn", ".xml"))]

resultados = []

for sbmn_file in sbmn_files:
    with open(os.path.join(PASTA_SBMN, sbmn_file), "r", encoding="utf-8") as f:
        sbmn_data = json.load(f)
        sbmn_text = sbmn_to_text(sbmn_data)

    log_ref = os.path.join(PASTA_LOGS, os.path.splitext(sbmn_file)[0] + ".xes")
    log_ref = log_ref if os.path.exists(log_ref) else None

    ref_path = os.path.join(PASTA_REF, os.path.splitext(sbmn_file)[0] + "_ref.bpmn")
    ref_path = ref_path if os.path.exists(ref_path) else None

    for i in range(len(bpmn_files)):
        for j in range(i + 1, len(bpmn_files)):
            bpmn1_path = os.path.join(PASTA_BPMN, bpmn_files[i])
            bpmn2_path = os.path.join(PASTA_BPMN, bpmn_files[j])

            bpmn1_text = bpmn_to_text(open(bpmn1_path, "r", encoding="utf-8").read())
            bpmn2_text = bpmn_to_text(open(bpmn2_path, "r", encoding="utf-8").read())

            metrics1 = calcular_metricas(bpmn1_path, log_ref)
            metrics2 = calcular_metricas(bpmn2_path, log_ref)

            if ref_path:
                sim1 = similaridade_estrutural(bpmn1_path, ref_path)
                sim2 = similaridade_estrutural(bpmn2_path, ref_path)
            else:
                sim1, sim2 = None, None

            vencedor, explicacao = avaliar_modelos_completo(
                sbmn_text, bpmn1_text, bpmn2_text, metrics1, metrics2, sim1, sim2
            )

            resultados.append({
                "SBMN_Arquivo": sbmn_file,
                "BPMN1_Arquivo": bpmn_files[i],
                "BPMN2_Arquivo": bpmn_files[j],
                "LLM_Voto": vencedor,
                "Explicacao_LLM": explicacao,
                "M1_Fitness": metrics1["fitness"],
                "M1_Precision": metrics1["precision"],
                "M1_Generalization": metrics1["generalization"],
                "M1_Simplicity": metrics1["simplicity"],
                "M1_Hmean": harmonic_mean(metrics1),
                "M1_Hmean_weighted": harmonic_mean_weighted(metrics1, W),
                "M1_SimEstrutural": sim1,
                "M2_Fitness": metrics2["fitness"],
                "M2_Precision": metrics2["precision"],
                "M2_Generalization": metrics2["generalization"],
                "M2_Simplicity": metrics2["simplicity"],
                "M2_Hmean": harmonic_mean(metrics2),
                "M2_Hmean_weighted": harmonic_mean_weighted(metrics2, W),
                "M2_SimEstrutural": sim2,
            })

df = pd.DataFrame(resultados)

# =========================
# 5. Exportar resultados
# =========================
df.to_csv("resultados_comparacao_final.csv", index=False)


# =========================
# 6. Exibir tabela estilizada
# =========================
def highlight_winner(row):
    color = [""] * len(row)
    if row["LLM_Voto"] == "Modelo 1":
        idxs = [df.columns.get_loc(c) for c in row.index if c.startswith("M1_")]
        for idx in idxs:
            color[idx] = "background-color: #b3ffb3"
    elif row["LLM_Voto"] == "Modelo 2":
        idxs = [df.columns.get_loc(c) for c in row.index if c.startswith("M2_")]
        for idx in idxs:
            color[idx] = "background-color: #b3ffb3"
    return color

styled = df.style.format(precision=3).apply(highlight_winner, axis=1)
display(styled)


# =========================
# 7. Gr√°ficos comparativos
# =========================
def plot_comparacao(row, save_dir=None):
    labels = ["Fitness", "Precision", "Generalization", "Simplicity", "Hmean", "Hmean_w"]
    m1_vals = [row[f"M1_{m}"] for m in ["Fitness", "Precision", "Generalization", "Simplicity", "Hmean", "Hmean_weighted"]]
    m2_vals = [row[f"M2_{m}"] for m in ["Fitness", "Precision", "Generalization", "Simplicity", "Hmean", "Hmean_weighted"]]

    x = np.arange(len(labels))
    width = 0.35

    fig, ax = plt.subplots(figsize=(10, 6))
    bars1 = ax.bar(x - width/2, m1_vals, width, label=row["BPMN1_Arquivo"])
    bars2 = ax.bar(x + width/2, m2_vals, width, label=row["BPMN2_Arquivo"])

    ax.set_ylabel("Valor")
    ax.set_ylim(0, 1.05)
    ax.set_title(f"{row['SBMN_Arquivo']} | Voto LLM: {row['LLM_Voto']}")
    ax.set_xticks(x)
    ax.set_xticklabels(labels)
    ax.legend()

    for bars in [bars1, bars2]:
        for bar in bars:
            height = bar.get_height()
            ax.annotate(f"{height:.2f}",
                        xy=(bar.get_x() + bar.get_width() / 2, height),
                        xytext=(0, 3), textcoords="offset points",
                        ha="center", va="bottom", fontsize=8)

    if save_dir:
        filename = f"{row['SBMN_Arquivo']}_{row['BPMN1_Arquivo']}_vs_{row['BPMN2_Arquivo']}.png".replace(" ", "_")
        plt.savefig(os.path.join(save_dir, filename), bbox_inches="tight")
    plt.show()


# Gerar gr√°ficos e salvar
for _, row in df.iterrows():
    plot_comparacao(row, save_dir=PASTA_GRAFICOS)

print(f"Gr√°ficos salvos em {PASTA_GRAFICOS}")